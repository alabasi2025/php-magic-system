<?php

namespace App\ApiServices;

use App\Models\Asset;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\ValidationException;
use Exception;

/**
 * AssetsApiService
 * 
 * RESTful API service for Assets system. Implements CRUD, Bulk, Export, and Import operations
 * with best practices including validation, database transactions, and comprehensive error handling.
 * 
 * @package App\ApiServices
 * @version 1.0.0
 */
class AssetsApiService
{
    protected $model;

    /**
     * Constructor to initialize the model instance.
     */
    public function __construct()
    {
        $this->model = new Asset();
    }

    /**
     * Get all assets with pagination.
     *
     * @param Request $request The incoming request, optionally containing 'per_page' parameter.
     * @return JsonResponse
     */
    public function index(Request $request): JsonResponse
    {
        try {
            $perPage = $request->get('per_page', 15);
            $assets = $this->model->paginate($perPage);

            return response()->json([
                'success' => true,
                'data' => $assets->items(),
                'meta' => [
                    'total' => $assets->total(),
                    'page' => $assets->currentPage(),
                    'per_page' => $assets->perPage(),
                    'last_page' => $assets->lastPage(),
                ],
            ]);
        } catch (Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to retrieve assets.',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Get a single asset record by ID.
     *
     * @param int $id The ID of the asset to retrieve.
     * @return JsonResponse
     */
    public function show(int $id): JsonResponse
    {
        try {
            $asset = $this->model->findOrFail($id);

            return response()->json([
                'success' => true,
                'data' => $asset,
            ]);
        } catch (\Illuminate\Database\Eloquent\ModelNotFoundException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Asset not found.',
            ], 404);
        } catch (Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to retrieve asset.',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Create a new asset record.
     *
     * @param Request $request The incoming request containing asset data.
     * @return JsonResponse
     */
    public function store(Request $request): JsonResponse
    {
        try {
            $rules = Asset::getValidationRules('create');
            $validatedData = Validator::make($request->all(), $rules)->validate();

            DB::beginTransaction();
            $asset = $this->model->create($validatedData);
            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Asset created successfully.',
                'data' => $asset,
            ], 201);
        } catch (ValidationException $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Validation failed.',
                'errors' => $e->errors(),
            ], 422);
        } catch (Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to create asset.',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Update an existing asset record.
     *
     * @param Request $request The incoming request containing updated asset data.
     * @param int $id The ID of the asset to update.
     * @return JsonResponse
     */
    public function update(Request $request, int $id): JsonResponse
    {
        try {
            $asset = $this->model->findOrFail($id);
            
            $rules = Asset::getValidationRules('update', $id);
            $validatedData = Validator::make($request->all(), $rules)->validate();

            DB::beginTransaction();
            $asset->update($validatedData);
            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Asset updated successfully.',
                'data' => $asset,
            ]);
        } catch (\Illuminate\Database\Eloquent\ModelNotFoundException $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Asset not found.',
            ], 404);
        } catch (ValidationException $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Validation failed.',
                'errors' => $e->errors(),
            ], 422);
        } catch (Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to update asset.',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Delete a single asset record.
     *
     * @param int $id The ID of the asset to delete.
     * @return JsonResponse
     */
    public function destroy(int $id): JsonResponse
    {
        try {
            $asset = $this->model->findOrFail($id);

            DB::beginTransaction();
            $asset->delete();
            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Asset deleted successfully.',
            ]);
        } catch (\Illuminate\Database\Eloquent\ModelNotFoundException $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Asset not found.',
            ], 404);
        } catch (Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to delete asset.',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Perform bulk operations (e.g., delete, update status) on multiple assets.
     *
     * Expected request body:
     * {
     *   "operation": "delete" | "update_status",
     *   "ids": [1, 2, 3],
     *   "status": "retired" (if operation is update_status)
     * }
     *
     * @param Request $request The incoming request containing the bulk operation details.
     * @return JsonResponse
     */
    public function bulk(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'operation' => ['required', 'string', 'in:delete,update_status'],
            'ids' => ['required', 'array'],
            'ids.*' => ['integer', 'exists:assets,id'],
            'status' => ['required_if:operation,update_status', 'string', 'in:active,retired,disposed'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'message' => 'Validation failed for bulk operation.',
                'errors' => $validator->errors(),
            ], 422);
        }

        $validatedData = $validator->validated();
        $ids = $validatedData['ids'];
        $operation = $validatedData['operation'];
        $affected = 0;

        try {
            DB::beginTransaction();

            if ($operation === 'delete') {
                $affected = $this->model->whereIn('id', $ids)->delete();
                $message = 'Successfully deleted ' . $affected . ' assets.';
            } elseif ($operation === 'update_status') {
                $status = $validatedData['status'];
                $affected = $this->model->whereIn('id', $ids)->update(['status' => $status]);
                $message = 'Successfully updated status to "' . $status . '" for ' . $affected . ' assets.';
            } else {
                throw new Exception('Invalid bulk operation specified.');
            }

            DB::commit();

            return response()->json([
                'success' => true,
                'message' => $message,
                'affected' => $affected,
            ]);
        } catch (Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Bulk operation failed.',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Export asset data to a file (e.g., CSV).
     * NOTE: In a real application, this would queue a job and return a download URL.
     *
     * @param Request $request The incoming request.
     * @return JsonResponse
     */
    public function export(Request $request): JsonResponse
    {
        try {
            // Simulate queuing an export job
            // In a real application, you would dispatch a job here:
            // ExportJob::dispatch($request->user()->id, $request->all());

            // For this implementation, we simulate success and return a placeholder URL
            $filename = 'assets_export_' . time() . '.csv';
            $downloadUrl = '/exports/' . $filename;

            return response()->json([
                'success' => true,
                'message' => 'Export job has been queued successfully.',
                'download_url' => $downloadUrl,
            ]);
        } catch (Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to queue export job.',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Import asset data from an uploaded file.
     * NOTE: In a real application, this would queue a job to process the file.
     *
     * @param Request $request The incoming request containing the file.
     * @return JsonResponse
     */
    public function import(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'file' => ['required', 'file', 'mimes:csv,txt', 'max:10240'], // Max 10MB
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'message' => 'Validation failed for import file.',
                'errors' => $validator->errors(),
            ], 422);
        }

        try {
            // Simulate file processing and import job
            $file = $request->file('file');
            $originalName = $file->getClientOriginalName();
            
            // In a real application, you would store the file and dispatch a job:
            // $path = $file->store('imports');
            // ImportJob::dispatch($path, $request->user()->id);

            // For this implementation, we simulate success
            $importedCount = rand(10, 50);
            $failedCount = rand(0, 5);

            return response()->json([
                'success' => true,
                'message' => "Import job for '{$originalName}' queued successfully.",
                'imported' => $importedCount,
                'failed' => $failedCount,
            ]);
        } catch (Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to process import file.',
                'error' => $e->getMessage(),
            ], 500);
        }
    }
}
