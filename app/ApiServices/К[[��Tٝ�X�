<?php

namespace App\ApiServices;

use App\Models\SalesInvoice;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\ValidationException;
use Symfony\Component\HttpFoundation\Response;

/**
 * BillingApiService
 * 
 * RESTful API service for Billing system, primarily managing SalesInvoices.
 * 
 * @package App\ApiServices
 * @version 1.0.0
 */
class BillingApiService
{
    /**
     * Get all Sales Invoices with pagination and filtering.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function index(Request $request): JsonResponse
    {
        try {
            $perPage = $request->get('per_page', 15);
            $query = SalesInvoice::query();

            // Simple filtering example
            if ($request->has('status')) {
                $query->where('status', $request->input('status'));
            }
            if ($request->has('customer_id')) {
                $query->where('customer_id', $request->input('customer_id'));
            }

            $invoices = $query->paginate($perPage);

            return response()->json([
                'success' => true,
                'data' => $invoices->items(),
                'meta' => [
                    'total' => $invoices->total(),
                    'page' => $invoices->currentPage(),
                    'per_page' => $invoices->perPage(),
                    'last_page' => $invoices->lastPage(),
                ],
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to retrieve invoices.',
                'error' => $e->getMessage(),
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Get a single Sales Invoice record.
     *
     * @param int $id
     * @return JsonResponse
     */
    public function show(int $id): JsonResponse
    {
        try {
            $invoice = SalesInvoice::findOrFail($id);

            return response()->json([
                'success' => true,
                'data' => $invoice,
            ]);
        } catch (\Illuminate\Database\Eloquent\ModelNotFoundException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Invoice not found.',
            ], Response::HTTP_NOT_FOUND);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to retrieve invoice.',
                'error' => $e->getMessage(),
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Create a new Sales Invoice record.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function store(Request $request): JsonResponse
    {
        $rules = [
            'customer_id' => 'required|integer|exists:customers,id',
            'invoice_date' => 'required|date',
            'total_amount' => 'required|numeric|min:0',
            'status' => 'sometimes|string|in:draft,sent,paid,cancelled',
        ];

        try {
            $validatedData = Validator::make($request->all(), $rules)->validate();

            DB::beginTransaction();

            $invoice = SalesInvoice::create($validatedData);

            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Sales Invoice created successfully.',
                'data' => $invoice,
            ], Response::HTTP_CREATED);
        } catch (ValidationException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Validation failed.',
                'errors' => $e->errors(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to create Sales Invoice.',
                'error' => $e->getMessage(),
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Update an existing Sales Invoice record.
     *
     * @param Request $request
     * @param int $id
     * @return JsonResponse
     */
    public function update(Request $request, int $id): JsonResponse
    {
        $rules = [
            'customer_id' => 'sometimes|integer|exists:customers,id',
            'invoice_date' => 'sometimes|date',
            'total_amount' => 'sometimes|numeric|min:0',
            'status' => 'sometimes|string|in:draft,sent,paid,cancelled',
        ];

        try {
            $validatedData = Validator::make($request->all(), $rules)->validate();

            DB::beginTransaction();

            $invoice = SalesInvoice::findOrFail($id);
            $invoice->update($validatedData);

            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Sales Invoice updated successfully.',
                'data' => $invoice,
            ]);
        } catch (ValidationException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Validation failed.',
                'errors' => $e->errors(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        } catch (\Illuminate\Database\Eloquent\ModelNotFoundException $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Invoice not found.',
            ], Response::HTTP_NOT_FOUND);
        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to update Sales Invoice.',
                'error' => $e->getMessage(),
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Delete a Sales Invoice record.
     *
     * @param int $id
     * @return JsonResponse
     */
    public function destroy(int $id): JsonResponse
    {
        try {
            DB::beginTransaction();

            $invoice = SalesInvoice::findOrFail($id);
            $invoice->delete();

            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Sales Invoice deleted successfully.',
            ]);
        } catch (\Illuminate\Database\Eloquent\ModelNotFoundException $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Invoice not found.',
            ], Response::HTTP_NOT_FOUND);
        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to delete Sales Invoice.',
                'error' => $e->getMessage(),
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Perform bulk operations (e.g., delete, update status) on multiple invoices.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function bulk(Request $request): JsonResponse
    {
        $rules = [
            'operation' => 'required|string|in:delete,update_status',
            'ids' => 'required|array',
            'ids.*' => 'integer|exists:sales_invoices,id',
            'status' => 'required_if:operation,update_status|string|in:draft,sent,paid,cancelled',
        ];

        try {
            $validatedData = Validator::make($request->all(), $rules)->validate();
            $ids = $validatedData['ids'];
            $operation = $validatedData['operation'];
            $affected = 0;

            DB::beginTransaction();

            if ($operation === 'delete') {
                $affected = SalesInvoice::whereIn('id', $ids)->delete();
                $message = 'Successfully deleted ' . $affected . ' invoices.';
            } elseif ($operation === 'update_status') {
                $status = $validatedData['status'];
                $affected = SalesInvoice::whereIn('id', $ids)->update(['status' => $status]);
                $message = 'Successfully updated status to "' . $status . '" for ' . $affected . ' invoices.';
            } else {
                $message = 'No operation performed.';
            }

            DB::commit();

            return response()->json([
                'success' => true,
                'message' => $message,
                'affected' => $affected,
            ]);
        } catch (ValidationException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Validation failed for bulk operation.',
                'errors' => $e->errors(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to perform bulk operation.',
                'error' => $e->getMessage(),
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Export Sales Invoice data based on filters.
     *
     * NOTE: In a real application, this would queue a job to generate a file (e.g., CSV, Excel)
     * and return a job ID or a temporary download URL. For this implementation, we simulate the process.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function export(Request $request): JsonResponse
    {
        // Validation for export filters (optional, but good practice)
        $rules = [
            'start_date' => 'sometimes|date',
            'end_date' => 'sometimes|date|after_or_equal:start_date',
            'format' => 'sometimes|string|in:csv,xlsx,pdf',
        ];

        try {
            Validator::make($request->all(), $rules)->validate();

            // Simulate the export process
            $filters = http_build_query($request->all());
            $fileName = 'sales_invoices_export_' . time() . '.csv';
            $downloadUrl = '/api/v1/billing/exports/' . $fileName . '?' . $filters;

            return response()->json([
                'success' => true,
                'message' => 'Export job initiated. File will be available shortly.',
                'download_url' => $downloadUrl,
            ]);
        } catch (ValidationException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Validation failed for export filters.',
                'errors' => $e->errors(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to initiate export.',
                'error' => $e->getMessage(),
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Import Sales Invoice data from an uploaded file.
     *
     * NOTE: In a real application, this would queue a job to process the file.
     * We simulate the file upload and job initiation.
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function import(Request $request): JsonResponse
    {
        $rules = [
            'file' => 'required|file|mimes:csv,xlsx|max:10240', // Max 10MB
        ];

        try {
            $validatedData = Validator::make($request->all(), $rules)->validate();

            // Simulate file processing and DB transaction
            DB::beginTransaction();

            // In a real scenario, the file would be stored and a job dispatched.
            $fileName = $validatedData['file']->getClientOriginalName();
            $importedCount = rand(10, 50); // Simulated
            $failedCount = rand(0, 5); // Simulated

            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Import of file "' . $fileName . '" completed.',
                'imported' => $importedCount,
                'failed' => $failedCount,
            ]);
        } catch (ValidationException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Validation failed for import file.',
                'errors' => $e->errors(),
            ], Response::HTTP_UNPROCESSABLE_ENTITY);
        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to process import.',
                'error' => $e->getMessage(),
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
}
